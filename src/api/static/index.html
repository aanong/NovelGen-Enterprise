<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NovelGen Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>
<body class="bg-gray-100">
    <div id="app" class="container mx-auto px-4 py-8">
        <header class="mb-8 flex justify-between items-center">
            <div>
                <h1 class="text-3xl font-bold text-gray-800">NovelGen Enterprise</h1>
                <p class="text-gray-600">AI å°è¯´ç”Ÿæˆæ§åˆ¶å°</p>
            </div>
            <div class="flex gap-4 items-center">
                <select v-model="selectedNovelId" @change="fetchData" class="border rounded px-3 py-2 bg-white">
                    <option v-for="novel in novels" :key="novel.id" :value="novel.id">
                        {{ novel.title }}
                    </option>
                </select>
                <button @click="fetchData" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">
                    åˆ·æ–°æ•°æ®
                </button>
                <button @click="triggerGeneration" :disabled="isGenerating || !selectedNovelId" 
                    class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                    {{ isGenerating ? 'ç”Ÿæˆä¸­...' : 'ç”Ÿæˆä¸‹ä¸€ç« ' }}
                </button>
            </div>
        </header>

        <!-- å®æ—¶ç”Ÿæˆç›‘æ§ -->
        <div v-if="isGenerating || streamingContent" class="mb-8 bg-white rounded-lg shadow-lg border-l-4 border-blue-500 overflow-hidden">
            <div class="p-4 bg-gray-50 border-b flex justify-between items-center">
                <div>
                    <h3 class="font-bold text-lg text-gray-800">ğŸš€ æ­£åœ¨ç”Ÿæˆä¸­...</h3>
                    <p class="text-sm text-gray-600">å½“å‰é˜¶æ®µ: <span class="font-mono bg-blue-100 text-blue-800 px-2 py-0.5 rounded">{{ currentStep }}</span></p>
                </div>
                <div class="animate-pulse flex space-x-2">
                    <div class="w-2 h-2 bg-blue-500 rounded-full"></div>
                    <div class="w-2 h-2 bg-blue-500 rounded-full animation-delay-200"></div>
                    <div class="w-2 h-2 bg-blue-500 rounded-full animation-delay-400"></div>
                </div>
            </div>
            <div class="p-6 max-h-96 overflow-y-auto font-serif text-lg leading-relaxed whitespace-pre-wrap bg-gray-50">
                {{ streamingContent }}<span class="animate-pulse">|</span>
            </div>
        </div>

        <!-- çŠ¶æ€æ¦‚è§ˆ -->
        <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
            <div class="bg-white p-6 rounded-lg shadow">
                <h3 class="text-lg font-semibold mb-2">å·²ç”Ÿæˆç« èŠ‚</h3>
                <p class="text-4xl font-bold text-blue-600">{{ chapters.length }}</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow">
                <h3 class="text-lg font-semibold mb-2">ç™»åœºè§’è‰²</h3>
                <p class="text-4xl font-bold text-purple-600">{{ characters.length }}</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow">
                <h3 class="text-lg font-semibold mb-2">å¤§çº²è¿›åº¦</h3>
                <p class="text-4xl font-bold text-green-600">{{ outlines.length }}</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow">
                <h3 class="text-lg font-semibold mb-2">èµ„æ–™åº“</h3>
                <p class="text-4xl font-bold text-orange-600">{{ referenceCount || '-' }}</p>
                <p class="text-xs text-gray-500 mt-1">æ¡ç›®æ•°é‡</p>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- ç« èŠ‚åˆ—è¡¨ -->
            <div class="lg:col-span-2">
                <h2 class="text-xl font-bold mb-4">ç« èŠ‚åˆ—è¡¨</h2>
                <div class="bg-white rounded-lg shadow overflow-hidden">
                    <div v-for="chapter in chapters" :key="chapter.id" class="border-b last:border-0 p-4 hover:bg-gray-50">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="font-bold text-lg">ç¬¬ {{ chapter.chapter_number }} ç« : {{ chapter.title || 'æ— æ ‡é¢˜' }}</h3>
                            <span class="text-sm text-gray-500">{{ formatDate(chapter.created_at) }}</span>
                        </div>
                        <p class="text-gray-600 line-clamp-3">{{ chapter.summary || 'æš‚æ— æ‘˜è¦' }}</p>
                        <button @click="viewChapter(chapter)" class="mt-2 text-blue-500 hover:text-blue-700 text-sm">
                            é˜…è¯»å…¨æ–‡
                        </button>
                    </div>
                    <div v-if="chapters.length === 0" class="p-8 text-center text-gray-500">
                        æš‚æ— ç« èŠ‚ï¼Œè¯·ç‚¹å‡»å³ä¸Šè§’ç”Ÿæˆã€‚
                    </div>
                </div>
            </div>

            <!-- ä¾§è¾¹æ  -->
            <div class="space-y-8">
                <!-- è§’è‰²åˆ—è¡¨ -->
                <div>
                    <h2 class="text-xl font-bold mb-4">æ´»è·ƒè§’è‰²</h2>
                    <div class="bg-white rounded-lg shadow p-4">
                        <div v-for="char in characters" :key="char.id" class="mb-4 last:mb-0 border-b last:border-0 pb-2">
                            <div class="flex justify-between">
                                <span class="font-bold">{{ char.name }}</span>
                                <span class="text-xs bg-gray-200 px-2 py-1 rounded">{{ char.role || 'é…è§’' }}</span>
                            </div>
                            <p class="text-sm text-gray-600 mt-1">å¿ƒæƒ…: {{ char.current_mood || 'æœªçŸ¥' }}</p>
                        </div>
                    </div>
                </div>

                <!-- å¤§çº²é¢„è§ˆ -->
                <div>
                    <h2 class="text-xl font-bold mb-4">åç»­å¤§çº²</h2>
                    <div class="bg-white rounded-lg shadow p-4">
                        <div v-for="outline in pendingOutlines" :key="outline.id" class="mb-3 text-sm">
                            <span class="font-bold text-gray-700">ç¬¬ {{ outline.chapter_number }} ç« :</span>
                            <span class="text-gray-600 ml-2">{{ outline.scene_description?.substring(0, 50) }}...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ç« èŠ‚é˜…è¯»æ¨¡æ€æ¡† -->
        <div v-if="selectedChapter" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
            <div class="bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
                <div class="p-4 border-b flex justify-between items-center">
                    <h2 class="text-xl font-bold">ç¬¬ {{ selectedChapter.chapter_number }} ç« : {{ selectedChapter.title }}</h2>
                    <button @click="selectedChapter = null" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                </div>
                <div class="p-6 overflow-y-auto prose max-w-none">
                    <div class="whitespace-pre-wrap">{{ selectedChapter.content }}</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, computed } = Vue;

        createApp({
            setup() {
                const novels = ref([]);
                const selectedNovelId = ref(null);
                const chapters = ref([]);
                const characters = ref([]);
                const outlines = ref([]);
                const isGenerating = ref(false);
                const selectedChapter = ref(null);
                
                // æ–°å¢çŠ¶æ€
                const streamingContent = ref('');
                const currentStep = ref('Ready');
                const referenceCount = ref(0); // æš‚æ—  APIï¼Œé¢„ç•™

                const pendingOutlines = computed(() => {
                    const lastChapterNum = chapters.value.length > 0 
                        ? Math.max(...chapters.value.map(c => c.chapter_number)) 
                        : 0;
                    return outlines.value.filter(o => o.chapter_number > lastChapterNum).slice(0, 5);
                });

                const fetchNovels = async () => {
                    try {
                        const res = await axios.get('/api/novels/');
                        novels.value = res.data;
                        if (novels.value.length > 0 && !selectedNovelId.value) {
                            selectedNovelId.value = novels.value[0].id;
                            fetchData();
                        }
                    } catch (error) {
                        console.error('Error fetching novels:', error);
                    }
                };

                const fetchData = async () => {
                    if (!selectedNovelId.value) return;
                    
                    try {
                        // å¹¶è¡Œè·å–æ•°æ®
                        const [chaptersRes, charsRes, outlinesRes] = await Promise.all([
                            axios.get(`/api/chapters/?novel_id=${selectedNovelId.value}`),
                            axios.get(`/api/characters/?novel_id=${selectedNovelId.value}`),
                            axios.get(`/api/outlines/?novel_id=${selectedNovelId.value}`)
                        ]);
                        
                        chapters.value = chaptersRes.data;
                        characters.value = charsRes.data;
                        outlines.value = outlinesRes.data;
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰æ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡ï¼ˆå¯é€‰ï¼Œå¦‚æœåç«¯æ”¯æŒæŸ¥è¯¢å½“å‰ä»»åŠ¡çŠ¶æ€ï¼‰
                        // ç›®å‰ä¸»è¦ä¾èµ– SSE ä¿æŒçŠ¶æ€
                    } catch (error) {
                        console.error('Error fetching data:', error);
                    }
                };

                const triggerGeneration = async () => {
                    if (!selectedNovelId.value) return;
                    
                    try {
                        isGenerating.value = true;
                        streamingContent.value = '';
                        currentStep.value = 'Initializing...';
                        
                        // 1. è§¦å‘ç”Ÿæˆä»»åŠ¡
                        const res = await axios.post('/api/generate/', { 
                            novel_id: selectedNovelId.value,
                            branch_id: 'main' 
                        });
                        
                        const taskId = res.data.task_id;
                        console.log(`Task started: ${taskId}`);
                        
                        // 2. å»ºç«‹ SSE è¿æ¥
                        startStream(taskId);
                        
                    } catch (error) {
                        console.error('Error triggering generation:', error);
                        isGenerating.value = false;
                        currentStep.value = 'Error';
                        alert('ç”Ÿæˆå¯åŠ¨å¤±è´¥: ' + (error.response?.data?.detail || error.message));
                    }
                };

                const startStream = (taskId) => {
                    const eventSource = new EventSource(`/api/generate/stream/${taskId}`);
                    
                    eventSource.onmessage = (event) => {
                        // é»˜è®¤æ¶ˆæ¯å¤„ç†ï¼ˆå¦‚æœæœ‰ï¼‰
                        console.log('SSE Message:', event.data);
                    };

                    eventSource.addEventListener('token', (event) => {
                        // å¤„ç†ç”Ÿæˆçš„æ–‡æœ¬ç‰‡æ®µ
                        // æ³¨æ„ï¼ševent.data å¯èƒ½æ˜¯ JSON å­—ç¬¦ä¸²ï¼Œä¹Ÿå¯èƒ½æ˜¯çº¯æ–‡æœ¬ï¼Œå–å†³äºåç«¯å®ç°
                        // å‡è®¾åç«¯å‘é€çš„æ˜¯çº¯æ–‡æœ¬ token
                        try {
                            // å°è¯•è§£æ JSONï¼Œå¦‚æœåç«¯åŒ…è£…äº†
                            const data = JSON.parse(event.data);
                            streamingContent.value += (data.content || data); 
                        } catch (e) {
                            // çº¯æ–‡æœ¬
                            streamingContent.value += event.data;
                        }
                        
                        // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                        // const container = document.querySelector('.max-h-96');
                        // if (container) container.scrollTop = container.scrollHeight;
                    });

                    eventSource.addEventListener('status', (event) => {
                        // æ›´æ–°å½“å‰æ­¥éª¤çŠ¶æ€
                        currentStep.value = event.data;
                        console.log('Status update:', event.data);
                        
                        if (event.data === 'completed' || event.data === 'failed') {
                            eventSource.close();
                            isGenerating.value = false;
                            fetchData(); // åˆ·æ–°æ•°æ®
                            if (event.data === 'completed') {
                                alert('ç« èŠ‚ç”Ÿæˆå®Œæˆï¼');
                            } else {
                                alert('ç”Ÿæˆå¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—ã€‚');
                            }
                        }
                    });

                    eventSource.onerror = (error) => {
                        console.error('SSE Error:', error);
                        eventSource.close();
                        isGenerating.value = false;
                        // å¦‚æœè¿æ¥æ–­å¼€ä½†ä»»åŠ¡è¿˜åœ¨è·‘ï¼Œå¯èƒ½éœ€è¦é‡è¿é€»è¾‘ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
                        fetchData();
                    };
                };

                const viewChapter = async (chapter) => {
                    try {
                        const res = await axios.get(`/api/chapters/${chapter.id}`);
                        selectedChapter.value = res.data;
                    } catch (error) {
                        alert('æ— æ³•åŠ è½½ç« èŠ‚å†…å®¹');
                    }
                };

                const formatDate = (dateStr) => {
                    if (!dateStr) return '';
                    return new Date(dateStr).toLocaleString();
                };

                onMounted(() => {
                    fetchNovels();
                });

                return {
                    novels,
                    selectedNovelId,
                    chapters,
                    characters,
                    outlines,
                    pendingOutlines,
                    isGenerating,
                    selectedChapter,
                    streamingContent,
                    currentStep,
                    referenceCount,
                    fetchData,
                    triggerGeneration,
                    viewChapter,
                    formatDate
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
